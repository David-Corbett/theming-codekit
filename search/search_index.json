{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Theming codekit This repository provides a series of tools and build scripts useful for developing resources that would be used to theme web content: write and compile scss to css apply appropriate prefixing for css rules write and uglify js detect features the user\u2019s browser has to offer (via Modernizr) code linting optimise and compress images for the web living style guide for the code via kss The kit uses NPM scripts and packages to create tooling to perform all of the above. Comprehensive documentation is provided herein on how to use the toolkit and how to configure additional applications should they be needed. The documentation is also online at https://david-corbett.github.io/theming-codekit/ .","title":"Home"},{"location":"#theming-codekit","text":"This repository provides a series of tools and build scripts useful for developing resources that would be used to theme web content: write and compile scss to css apply appropriate prefixing for css rules write and uglify js detect features the user\u2019s browser has to offer (via Modernizr) code linting optimise and compress images for the web living style guide for the code via kss The kit uses NPM scripts and packages to create tooling to perform all of the above. Comprehensive documentation is provided herein on how to use the toolkit and how to configure additional applications should they be needed. The documentation is also online at https://david-corbett.github.io/theming-codekit/ .","title":"Theming codekit"},{"location":"documentation/documentation/","text":"Documentation Running our documentation locally requires the use of MkDocs . MkDocs is a fast, simple and downright gorgeous static site generator that's geared towards building project documentation. Documentation source files are written in Markdown, and configured with a single YAML configuration file. We use MkDocs to build a static HTML site that we host on GitLab pages. There's a stack of good looking themes available for MkDocs. The mkdocs.yml file in the repository is configured to use the Material for MkDocs theme. Getting started It is possible to install MkDocs a package manager (such as apt-get, dnf, homebrew, yum, chocolatey, etc.). However this can pose some compatibility issues, particularly on Mac OSX.","title":"Documentation"},{"location":"documentation/documentation/#documentation","text":"Running our documentation locally requires the use of MkDocs . MkDocs is a fast, simple and downright gorgeous static site generator that's geared towards building project documentation. Documentation source files are written in Markdown, and configured with a single YAML configuration file. We use MkDocs to build a static HTML site that we host on GitLab pages. There's a stack of good looking themes available for MkDocs. The mkdocs.yml file in the repository is configured to use the Material for MkDocs theme.","title":"Documentation"},{"location":"documentation/documentation/#getting-started","text":"It is possible to install MkDocs a package manager (such as apt-get, dnf, homebrew, yum, chocolatey, etc.). However this can pose some compatibility issues, particularly on Mac OSX.","title":"Getting started"},{"location":"documentation/kss/","text":"KSS","title":"KSS"},{"location":"documentation/kss/#kss","text":"","title":"KSS"},{"location":"documentation/mkdocs/","text":"mkdocs Documentation for the toolkit and the repository is created using MkDocs .","title":"mkdocs"},{"location":"documentation/mkdocs/#mkdocs","text":"Documentation for the toolkit and the repository is created using MkDocs .","title":"mkdocs"},{"location":"getting-started/build-tools/","text":"Build Tools Installation The codekit uses NPM scripts and packages to create tooling that a developer would ideally like to have for theming web content. Therefore to get started, the developer must have NPM installed on their machine. To see if you already have Node.js and npm installed, check the installed version, run the following commands in a terminal window: node -v npm -v Both commands should return a version number similar to v10.x.x or 6.x.x (where x is a valid integer). More information on installing NPM on various platforms and devices is available on the NPM website . When you are sure that Node.js and npm are installed on the machine, open a terminal and navigate to the root directory of the project where the package.json file is located and run npm install to install our local dependencies listed in package.json . Tooling setup With the codekit using NPM scripts for its build system, the package.json includes convenient methods for working with the framework, including compiling code, running tests, and more. Using NPM scripts The package.json includes the following commands and tasks: Task Description npm run build npm run build compiles files into their build directories ready for use in a production environment. Uses Sass , Autoprefixer , and UglifyJS . npm run watch Watches for changes to scss and js files compiles them for development purposes. npm run lint Will run all .scss and .js files through their respective linting tools - eslint sass-lint npm run lint-scss Will run all .scss files through sass-lint . The command can also accept a parameter to lint an individual file. To do this npm run lint-scss -- scssfile:name-of-file where name-of-file is the file you want to lint relative to the package.json for the project. npm run docs-serve Starts a local server to view documentation on and will automatically update as changes are saved. Run npm run to see all the npm scripts. Troubleshooting Should you encounter problems with installing dependencies, uninstall all previous dependency versions (global and local). Then, rerun npm install .","title":"Build tools"},{"location":"getting-started/build-tools/#build-tools","text":"","title":"Build Tools"},{"location":"getting-started/build-tools/#installation","text":"The codekit uses NPM scripts and packages to create tooling that a developer would ideally like to have for theming web content. Therefore to get started, the developer must have NPM installed on their machine. To see if you already have Node.js and npm installed, check the installed version, run the following commands in a terminal window: node -v npm -v Both commands should return a version number similar to v10.x.x or 6.x.x (where x is a valid integer). More information on installing NPM on various platforms and devices is available on the NPM website . When you are sure that Node.js and npm are installed on the machine, open a terminal and navigate to the root directory of the project where the package.json file is located and run npm install to install our local dependencies listed in package.json .","title":"Installation"},{"location":"getting-started/build-tools/#tooling-setup","text":"With the codekit using NPM scripts for its build system, the package.json includes convenient methods for working with the framework, including compiling code, running tests, and more.","title":"Tooling setup"},{"location":"getting-started/build-tools/#using-npm-scripts","text":"The package.json includes the following commands and tasks: Task Description npm run build npm run build compiles files into their build directories ready for use in a production environment. Uses Sass , Autoprefixer , and UglifyJS . npm run watch Watches for changes to scss and js files compiles them for development purposes. npm run lint Will run all .scss and .js files through their respective linting tools - eslint sass-lint npm run lint-scss Will run all .scss files through sass-lint . The command can also accept a parameter to lint an individual file. To do this npm run lint-scss -- scssfile:name-of-file where name-of-file is the file you want to lint relative to the package.json for the project. npm run docs-serve Starts a local server to view documentation on and will automatically update as changes are saved. Run npm run to see all the npm scripts.","title":"Using NPM scripts"},{"location":"getting-started/build-tools/#troubleshooting","text":"Should you encounter problems with installing dependencies, uninstall all previous dependency versions (global and local). Then, rerun npm install .","title":"Troubleshooting"},{"location":"image-tools/image-opt/","text":"Image Optimisation Start by reading this excellent essential image optimisation ebook by Addy Osmani. The image optimisation tools used in the codekit are configured to implement his recommendations and are loosely based on the great ImageOptim app for Mac. Image optimisation / minification is performed using the node imagemin package. This node package provides a pluggable api where a range of common compression tools can be used to optimise images in a lossless manor. https://freshman.tech/image-optimisation/ documents an example of how to configure the imagemin node package and settings for each of the compression plugins can be found on their npm package page (linked in the table below). Images can be passed through multiple filters to try and obtain the optimal compression. Plugin Use imagemin-gifsicle GIF optimisation imagemin-jpegoptim Jpeg optimisation imagemin-jpegtran Jpeg optimisation imagemin-optipng png optimisation imagemin-pngcrush png optimisation imagemin-pngout png optimisation imagemin-zopfli png optimisation Settings and the compression algorithms are defined and configured in the imagemin.js file. Images added to the src/images directory are automatically optimised and output to the images directory as part of the main npm run watch and npm run build scripts.","title":"Image Optimisation"},{"location":"image-tools/image-opt/#image-optimisation","text":"Start by reading this excellent essential image optimisation ebook by Addy Osmani. The image optimisation tools used in the codekit are configured to implement his recommendations and are loosely based on the great ImageOptim app for Mac. Image optimisation / minification is performed using the node imagemin package. This node package provides a pluggable api where a range of common compression tools can be used to optimise images in a lossless manor. https://freshman.tech/image-optimisation/ documents an example of how to configure the imagemin node package and settings for each of the compression plugins can be found on their npm package page (linked in the table below). Images can be passed through multiple filters to try and obtain the optimal compression. Plugin Use imagemin-gifsicle GIF optimisation imagemin-jpegoptim Jpeg optimisation imagemin-jpegtran Jpeg optimisation imagemin-optipng png optimisation imagemin-pngcrush png optimisation imagemin-pngout png optimisation imagemin-zopfli png optimisation Settings and the compression algorithms are defined and configured in the imagemin.js file. Images added to the src/images directory are automatically optimised and output to the images directory as part of the main npm run watch and npm run build scripts.","title":"Image Optimisation"},{"location":"image-tools/svg/","text":"SVG Optimisation","title":"SVG Optimisation"},{"location":"image-tools/svg/#svg-optimisation","text":"","title":"SVG Optimisation"},{"location":"js/modernizr/","text":"Modernizr Modernizr is a small piece of JavaScript code that automatically detects the availability of next-generation web technologies in your user's browsers. Rather than blacklisting entire ranges of browsers based on \u201cUA sniffing\u201d, Modernizr uses feature detection to allow you to easily tailor your user's experiences based on the actual capabilities of their browser. With this knowledge that Modernizr gives you, you can take advantage of these new features in the browsers that can render or utilize them, and still have easy and reliable means of controlling the situation for the browsers that cannot. The more recent versions of Modernizr no longer provide a single, base modernizr.js file. This way the smallest file possible is provided, which means a faster website for your customers. Getting started Head over to the Modernizr download page, select the features you want to use in your project. Once you have done that, just hit the Build button Download or copy the configuration file from the build menu (under \"Command Line Config\"). This will give you a JSON file that should be placed in the config/ directory to enable the Modernizr module to make your custom build. Detects can be added to and removed at any time during the product lifecycle by updating this file. npm run modernizr The npm build script will always run the modernizr build script as one of the tasks for compiling code for the production environment. This ensures that any changes applied the modernizr-config.json are updated in the production build. If you are not using modernizr to detect browser capabilities, simply don't include the js/modernizr.min.js file in the head of the html for pages on your site. Further reading Full documentation is provided on the Modernizr website .","title":"modernizr"},{"location":"js/modernizr/#modernizr","text":"Modernizr is a small piece of JavaScript code that automatically detects the availability of next-generation web technologies in your user's browsers. Rather than blacklisting entire ranges of browsers based on \u201cUA sniffing\u201d, Modernizr uses feature detection to allow you to easily tailor your user's experiences based on the actual capabilities of their browser. With this knowledge that Modernizr gives you, you can take advantage of these new features in the browsers that can render or utilize them, and still have easy and reliable means of controlling the situation for the browsers that cannot. The more recent versions of Modernizr no longer provide a single, base modernizr.js file. This way the smallest file possible is provided, which means a faster website for your customers.","title":"Modernizr"},{"location":"js/modernizr/#getting-started","text":"Head over to the Modernizr download page, select the features you want to use in your project. Once you have done that, just hit the Build button Download or copy the configuration file from the build menu (under \"Command Line Config\"). This will give you a JSON file that should be placed in the config/ directory to enable the Modernizr module to make your custom build. Detects can be added to and removed at any time during the product lifecycle by updating this file. npm run modernizr The npm build script will always run the modernizr build script as one of the tasks for compiling code for the production environment. This ensures that any changes applied the modernizr-config.json are updated in the production build. If you are not using modernizr to detect browser capabilities, simply don't include the js/modernizr.min.js file in the head of the html for pages on your site.","title":"Getting started"},{"location":"js/modernizr/#further-reading","text":"Full documentation is provided on the Modernizr website .","title":"Further reading"},{"location":"linting/linting/","text":"Linting tools The codekit provides linting for .js and .scss files, to ensure compliance with coding standards. Using NPM scripts The package.json includes the following commands and tasks: Task Description npm run lint Will run all .scss and .js files through their respective linting tools - eslint sass-lint npm run lint-scss Will run all .scss files through sass-lint . The command can also accept a parameter to lint an individual file. To do this npm run lint-scss -- scssfile:name-of-file where name-of-file is the file you want to lint relative to the package.json for the project. NB space after -- before the scssfile variable is passed. SCSS Linting Sass-lint is a node only linter for both sass and scss syntax. Sass-lint is configured from a .sass-lint.yml or .scsslintrc file in the project. A .sass-lint.yml with sensible defaults is provided as part of the codekit. If you don't have either file in the root of your project or you would like all your projects to follow a standard config file then you can specify the path to one in your project's package.json file with the sasslintConfig option. For example: { name : my-project , version : 1.0.0 , config : { sasslintConfig : PATH/TO/YOUR/CONFIG/FILE } } Rules For all rules , setting their severity to 0 turns it off, setting to 1 sets it as a warning (something that should not be committed in), and setting to 2 sets it to an error (something that should not be written). If a rule is set to just a severity, it will use the default configuration (where available). The severity of the warning(s) will have an impact on the console output - it is important to scroll up and read the output from where the command was invoked. For more severe warnings, the end of the console output might look like this npm ERR! A complete log of this run can be found in: npm ERR! /Users/username/.npm/_logs/2019-05-15T13_41_42_641Z-debug.log Special comments can be used to disable and enable certain rules throughout your source files in a variety of scenarios. These can be useful when dealing with legacy code or with certain necessary code smells. You can read the documentation for this feature here . Below are examples of how to use this feature: Disable a rule for the entire file // sass-lint:disable border-zero p { border : none ; // No lint reported } Disable more than 1 rule // sass-lint:disable border-zero, quotes p { border : none ; // No lint reported content : hello ; // No lint reported } Disable a rule for a single line p { border : none ; // sass-lint :disable-line border-zero } Disable all lints within a block (and all contained blocks) p { // sass-lint:disable-block border-zero border : none ; // No result reported } a { border : none ; // Failing result reported } Disable and enable again // sass-lint:disable border-zero p { border : none ; // No result reported } // sass-lint:enable border-zero a { border : none ; // Failing result reported } Disable/enable all linters // sass-lint:disable-all p { border : none ; // No result reported } // sass-lint:enable-all a { border : none ; // Failing result reported }","title":"Linting"},{"location":"linting/linting/#linting-tools","text":"The codekit provides linting for .js and .scss files, to ensure compliance with coding standards.","title":"Linting tools"},{"location":"linting/linting/#using-npm-scripts","text":"The package.json includes the following commands and tasks: Task Description npm run lint Will run all .scss and .js files through their respective linting tools - eslint sass-lint npm run lint-scss Will run all .scss files through sass-lint . The command can also accept a parameter to lint an individual file. To do this npm run lint-scss -- scssfile:name-of-file where name-of-file is the file you want to lint relative to the package.json for the project. NB space after -- before the scssfile variable is passed.","title":"Using NPM scripts"},{"location":"linting/linting/#scss-linting","text":"Sass-lint is a node only linter for both sass and scss syntax. Sass-lint is configured from a .sass-lint.yml or .scsslintrc file in the project. A .sass-lint.yml with sensible defaults is provided as part of the codekit. If you don't have either file in the root of your project or you would like all your projects to follow a standard config file then you can specify the path to one in your project's package.json file with the sasslintConfig option. For example: { name : my-project , version : 1.0.0 , config : { sasslintConfig : PATH/TO/YOUR/CONFIG/FILE } }","title":"SCSS Linting"},{"location":"linting/linting/#rules","text":"For all rules , setting their severity to 0 turns it off, setting to 1 sets it as a warning (something that should not be committed in), and setting to 2 sets it to an error (something that should not be written). If a rule is set to just a severity, it will use the default configuration (where available). The severity of the warning(s) will have an impact on the console output - it is important to scroll up and read the output from where the command was invoked. For more severe warnings, the end of the console output might look like this npm ERR! A complete log of this run can be found in: npm ERR! /Users/username/.npm/_logs/2019-05-15T13_41_42_641Z-debug.log Special comments can be used to disable and enable certain rules throughout your source files in a variety of scenarios. These can be useful when dealing with legacy code or with certain necessary code smells. You can read the documentation for this feature here . Below are examples of how to use this feature:","title":"Rules"},{"location":"linting/linting/#disable-a-rule-for-the-entire-file","text":"// sass-lint:disable border-zero p { border : none ; // No lint reported }","title":"Disable a rule for the entire file"},{"location":"linting/linting/#disable-more-than-1-rule","text":"// sass-lint:disable border-zero, quotes p { border : none ; // No lint reported content : hello ; // No lint reported }","title":"Disable more than 1 rule"},{"location":"linting/linting/#disable-a-rule-for-a-single-line","text":"p { border : none ; // sass-lint :disable-line border-zero }","title":"Disable a rule for a single line"},{"location":"linting/linting/#disable-all-lints-within-a-block-and-all-contained-blocks","text":"p { // sass-lint:disable-block border-zero border : none ; // No result reported } a { border : none ; // Failing result reported }","title":"Disable all lints within a block (and all contained blocks)"},{"location":"linting/linting/#disable-and-enable-again","text":"// sass-lint:disable border-zero p { border : none ; // No result reported } // sass-lint:enable border-zero a { border : none ; // Failing result reported }","title":"Disable and enable again"},{"location":"linting/linting/#disableenable-all-linters","text":"// sass-lint:disable-all p { border : none ; // No result reported } // sass-lint:enable-all a { border : none ; // Failing result reported }","title":"Disable/enable all linters"},{"location":"scss/layout/","text":"Layout","title":"layout"},{"location":"scss/layout/#layout","text":"","title":"Layout"},{"location":"scss/scss-introduction/","text":"SCSS The codekit provides a way to compile sass/scss files into css via node-sass . Node-sass is a library that provides binding for Node.js to LibSass, the C version of the popular stylesheet preprocessor, Sass. It allows you to natively compile .scss files to css at incredible speed and automatically via a connect middleware. Scripts for scss The package.json includes the following commands and tasks: Task Description npm run build npm run build compiles files into their build directories ready for use in a production environment. .scss files are linted, then compiled using the minify script (below) then run through the postcss autoprefixer function. npm run watch Watches for changes to .scss files in /src/scss compiles them for development purposes. npm run scss:dev will compile all .scss files for development purposes, with code expanded, comments included including mappings to the source files to make debugging simplier. npm run scss:prod will compile all .scss files for production purpose, comments and unnecessary code is removed and the file is minified. npm run autoprefixer will parse any .css file in the /css directory and add vendor prefixes to CSS rules using values from Can I Use The scss scripts are configured to take .scss files in the /src/scss directory and builds / compiles them to a /css directory (if the directory does not exist, it will be created). Autoprefixer The codekit uses Autoprefixer (included in the build process) to automatically add vendor prefixes to some CSS properties at build time. Doing so saves time and code by allowing us to write key parts of our CSS a single time while eliminating the need for vendor mixins. We maintain the list of browsers supported through Autoprefixer in a separate file within our GitHub repository. See package.json for details.","title":"scss introduction"},{"location":"scss/scss-introduction/#scss","text":"The codekit provides a way to compile sass/scss files into css via node-sass . Node-sass is a library that provides binding for Node.js to LibSass, the C version of the popular stylesheet preprocessor, Sass. It allows you to natively compile .scss files to css at incredible speed and automatically via a connect middleware.","title":"SCSS"},{"location":"scss/scss-introduction/#scripts-for-scss","text":"The package.json includes the following commands and tasks: Task Description npm run build npm run build compiles files into their build directories ready for use in a production environment. .scss files are linted, then compiled using the minify script (below) then run through the postcss autoprefixer function. npm run watch Watches for changes to .scss files in /src/scss compiles them for development purposes. npm run scss:dev will compile all .scss files for development purposes, with code expanded, comments included including mappings to the source files to make debugging simplier. npm run scss:prod will compile all .scss files for production purpose, comments and unnecessary code is removed and the file is minified. npm run autoprefixer will parse any .css file in the /css directory and add vendor prefixes to CSS rules using values from Can I Use The scss scripts are configured to take .scss files in the /src/scss directory and builds / compiles them to a /css directory (if the directory does not exist, it will be created).","title":"Scripts for scss"},{"location":"scss/scss-introduction/#autoprefixer","text":"The codekit uses Autoprefixer (included in the build process) to automatically add vendor prefixes to some CSS properties at build time. Doing so saves time and code by allowing us to write key parts of our CSS a single time while eliminating the need for vendor mixins. We maintain the list of browsers supported through Autoprefixer in a separate file within our GitHub repository. See package.json for details.","title":"Autoprefixer"}]}